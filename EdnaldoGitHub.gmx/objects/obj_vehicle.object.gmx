<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_sonic_idle</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>spr_player_mask_main</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Variables.

 // Init. flag:
    initialized     = false;      // Checks if the player has been initialized.
    
 // Horizontal movement:
    x_speed         = 0;        // The current horizontal speed.
    x_speed_top     = 6;        // Horizontal top speed while on flat ground.
    x_speed_max     = 16;       // Fastest the player can move.
    g_speed         = 0;        // Stores the ground speed.
    x_acceleration  = 0.046875; // Horizontal acceleration on ground.
    x_deceleration  = 0.5;      // Horizontal deceleration on ground.
    x_slope_factor  = 0.125;    // Rate at which the player slows down on slopes.
    x_air_accel     = 0.09375;  // Acceleration value in the air.
    x_temp_accel    = 0;        // Stores temporal acceleration value. 
    x_temp_decel    = 0;        // Stores temporal deceleration value.
    x_temp_friction = 0;        // Stores temporal friction value.
    x_limit         = false;    // Limits the horizontal speed.
    x_allow         = 1;        // Allows horizontal movement.

 // Vertical movement:
    y_speed         = 0;        // The current vertical speed.
    y_speed_max     = 16;       // Fastest the player can fall.
    y_acceleration  = 0.21875;  // Force of gravity applied to the player.
    y_accel_common  = 0.21875;  // Store original gravity value in case we change it ingame.
    y_conversion    = 1;        // Speed conversion when landing.
    y_limit         = true;     // Limits the vertical speed.
    y_allow         = 1;        // Allows vertical movement.

 // Samples.
    x_sample        = 13;       // Pixel limit to divide horizontal movement.
    y_sample        = 13;       // Pixel limit to divide vertical movement.
          
 // Terrain:
    ground          = 0;        // Checks if the player has/is grounded.
    ground_prev = 0;
    angle           = 0;        // Returns the angle of the player.
    angle_round     = 0;        // Returns the angle of the player, rounded.
    angle_relative  = 0;        // Returns the angle, relative to gravity values.
    angle_hold      = 0;        // Used to smoothen angle values.
    collision_layer = 0;        // Returns the layers the player is on.
    floor_mode      = 0;        // Returns the floor mode.
    x_beforepush    = 0;        // X Position before player was pushed (not used)      
    y_beforepush    = 0;        // Y Position before player was pushed (not used)
    platform_check  = 0;        // Checks if the player has landed on platforms.
    platform_frames = 30;       // Used to reset the platform check.
   
 // States:
    jump_strength     = -6.5    // Players jump strength.
    jump_release      = -4;     // Minimum strength the player can jump.
    jump_completed    = false;  // Checks if the player has completed his jump.
    jump_lock         = 0;      // Is the jump locked? (Means the direction cannot be altered while jumping)
    
    spindash_strength = 0;      // Current strength of the spindash.
    spindash_pitch    = 0;      // Used to change the spindash sound pitch.
    
    roll_deceleration = 0.125;     // Rolling deceleration.
    roll_friction     = 0.0234375  // Friction while rolling.
    roll_decel_up     = 0.078125;  // Deceleration while rolling up slopes.
    roll_decel_down   = 0.3125;    // Deceleration while rolling down slopes.
    
    skid_direction    = 0;         // Direction you're skiddin towards.
    
    grab_timer        = 0;         // Grab timer, prevents us from grabbing onto something as soon as we try to let go.
    grab_type         = 0;         // Grab type, see the grab scripts for more.
    grab_distance     = 0;         // How far we can travel.
    grab_moving       = 0;         // Checks if we're moving-
    grab_id           = 0;
    grab_x            = 0;
    grab_y            = 0;
    
    push_timer        = 0;         // Used to trigger pushing state.
    push_timer_max    = 3;
    
    death_timer       = -5;       // See death script in the step event.

  // Flags:
    state           = 1;        // Players current state.
    input_alarm     = 0;        // Input alarm. (Used for slopes9
    input_alarm_dir = 0;        // Which direction we're locking.
    input_lock_l    = 0;        // Locks left input.
    input_lock_r    = 0;        // Locks right input.
    input_lock_s    = 0;        // locks input after using a horizontal spring.
    launch_lock     = 0;        // Disables horizontal input.
    lock_timer      = 0;        // How long input is locked. Used on springs.
    tunnel_lock     = 0;        // Locks the player when inside a tunnel.
    timer_up        = 0;        // Timer for looking up.
    timer_down      = 0;        // Timer for crouching.
    allow_look      = 1;        // Allow crouching/looking up.
    physic_mode     = 0;
    speedshoe       = 0;
    
  // Done initializing.
    initialized = true;
    player_index = CHAR_EDNALDO;
    animation_init()
    animation = "normal";
    animation_direction = 1;
    animation_angle = 0;
    animation_speed = 0;
    animation_frame = 0;
    aft_timer = 0;

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Inputs keys.
 
    input_up               = false;
    input_down             = false;
    input_right            = false;
    input_left             = false;
    input_action           = false;
    input_special          = false;
    
    input_up_pressed       = false;
    input_down_pressed     = false;
    input_right_pressed    = false;
    input_left_pressed     = false;
    input_action_pressed   = false;
    input_special_pressed  = false;    
    
    input_up_released      = false;
    input_down_released    = false;
    input_right_released   = false;
    input_left_released    = false;
    input_action_released  = false;
    input_special_released = false;    
    
    input_alarm = false;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>301</id>
        <kind>0</kind>
        <userelative>-1</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>1</exetype>
        <functionname>action_set_alarm</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>0</kind>
            <string>10</string>
          </argument>
          <argument>
            <kind>4</kind>
            <string>0</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>obj_camera.cam_obj = self.id;
initialized = true;
state = STATE_DEFAULT;
    aud_play_simple(snd_car_land);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// States
vehicle_state_jump()
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Animations
if x_speed != 0
{
    animation_speed = abs(x_speed)/25;
}
animation_frame += animation_speed;

if abs(x_speed) &gt; 9
{
    if !ground
    {
       if aft_timer &lt;= 0
        {
            scr_afterimage_ext(sprite_index, animation_frame, floor(x), floor(y), 1, 1, 0.8, animation_angle, c_white, 0.1);
            aft_timer = 5;
        }
        else
        {
            aft_timer --;
        }
    }
    else
    {
        if animation_angle = 0
        {
        dummy_effect_create_speed(sprSmoke8, random(1), floor(x) - (40 * animation_direction), bbox_bottom - 3, 2, 0, (5 + random(abs(x_speed/2))) * -animation_direction, -random(10), 0.2)    
        }
    }
}

if abs(x_speed) &gt; 12
{
    scr_sparkle()
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Sprite rotation.
 // This is used for rotating the players sprite.
 
 // Exit if not initialized, death or hurt.
    if(initialized = false || state = STATE_DEATH || state == STATE_HURT) exit;
 
 // Change animation angle values:
    if(ground)
    {
       if(vehicle_collision_check(COL_BOTTOM_OBJECT, MASK_MAIN, x, y, angle, par_solid_no_angle) || vehicle_collision_check(COL_BOTTOM_OBJECT, MASK_MAIN, x, y, angle, par_platform_no_angle)
       || vehicle_collision_check(COL_BOTTOM_OBJECT, MASK_MAIN, x, y, angle, par_layer0_no_angle) || vehicle_collision_check(COL_BOTTOM_OBJECT, MASK_MAIN, x, y, angle, par_layer1_no_angle))
       {       
          animation_angle_mod = 0;
       }
       else
       {
          var _angMod;
          _angMod = animation_angle_mod;
             
          if(angle &gt;= 0 &amp;&amp; angle &lt;= 180)
          {
             if(angle &lt; 36)
             {
                _angMod = 0;
             }
                else
             {
                _angMod = angle;
             }
          }
          if(angle &gt;= 180 &amp;&amp; angle &lt;= 360)
          {
             if(angle &gt; 360-36)
             {
                _angMod = 0;
             }
             else
             {
                _angMod = angle;
             }
          }
          if(abs(angle_difference(animation_angle_mod, _angMod))&lt;45)
          {
             animation_angle_mod = rotate_towards(_angMod, animation_angle_mod, max(4, abs(x_speed)));
          }
          else
          {
             animation_angle_mod = _angMod;
          }
       } 
    }
    else
    {
       animation_angle_mod = rotate_towards(0, animation_angle_mod, 4)
    }
 
 // Rotate:   
    if(global.angle_mode == 0)
    { 
       animation_angle  = round(animation_angle_mod/45)*45;
    }
    else
    {
       animation_angle  = animation_angle_mod;
    } 
    
 // Set angle to zero and exit if we're not using a animation that can be rotated.
    if(animation == "idle" || animation == "idle bored" || animation == "lookup" || animation == "crouch" || animation == "spindash" || animation == "roll" || animation == "push" || animation == "hurt" 
    || animation == "balance" || animation == "balance 2" || animation == "fly" || animation == "swim" || animation == "fly exhausted" || animation == "swim exhausted" || animation == "glide"
    || animation == "glide drop" || animation == "slide" || animation == "ledge climb" || animation == "climb") 
    {
       animation_angle = 0;
    }
    
 
 
 

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if ground != ground_prev
{
    if ground = false
    {
        aud_play_simple(snd_drift);
    }
    
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Receive inputs.

 // Exit if not initialized or death.
    if(initialized = false || state = STATE_DEATH) exit;
  
 // Key held.   
    input_up               = keyboard_check(global.key_up);
    input_down             = keyboard_check(global.key_down);

    if ground
    {
        input_right = true;
    }
    else
    {
        keyboard_check(global.key_right);
    }
    
    
    input_left             = keyboard_check(global.key_left);
    input_action           = keyboard_check(global.key_action);
    input_special          = keyboard_check(global.key_special);
    
 // Key press.
    input_up_pressed       = keyboard_check_pressed(global.key_up);
    input_down_pressed     = keyboard_check_pressed(global.key_down);
    input_right_pressed    = keyboard_check_pressed(global.key_right);
    input_left_pressed     = keyboard_check_pressed(global.key_left);
    input_action_pressed   = keyboard_check_pressed(global.key_action);
    input_special_pressed  = keyboard_check_pressed(global.key_special);    

 // Key release.    
    input_up_released      = keyboard_check_released(global.key_up);
    input_down_released    = keyboard_check_released(global.key_down);
    input_right_released   = keyboard_check_released(global.key_right);
    input_left_released    = keyboard_check_released(global.key_left);
    input_action_released  = keyboard_check_released(global.key_action);
    input_special_released = keyboard_check_released(global.key_special);    

 // Disable input if both left and right is being held.
    if(input_left &amp;&amp; input_right)
    {
       input_left  = false;
       input_right = false;
    }
    
 // Input alarm.
    if(input_alarm)
    {
       if(input_alarm_dir == 1)
       {
          input_right = false;
       }
       if(input_alarm_dir == -1)
       {
          input_left = false;
       }
    }
    
 // Input locks (spring)
    if(input_lock_l)
    {
       input_left = false;
    }
    if(input_lock_r)
    {
       input_right = false;
    }

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Physics

 // Previous Positions:
    previous_x = x;
    previous_y = y;
    ground_prev = ground;
    
vehicle_physics()
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if obj_player.state = STATE_DEATH &amp;&amp; visible = true
{
    dummy_effect_create(spr_stock_explosion,0.1,x,y,-10,0);
    visible = false;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Collision Detecting and Movement.

 // Exit if not initialized or death.
    if(initialized = false || state = STATE_DEATH) exit;

 // Set temporal sample variables:
    var _steps, _samples;
    
 // Limit the horizontal speed:
    if(x_limit)
    {
       x_speed = clamp(x_speed, -xspeed_max, x_speed_max);
    }
    
 // Set steps/samples:
    _steps = 1;
    if(x_sample &gt; 0)
    {
       _steps += floor(abs(x_speed)/x_sample);  
    }
    _samples = x_speed/_steps;
     
 // Move horizontally:
    repeat(_steps)
    {
           x += dcos(angle)*_samples;
           y -= dsin(angle)*_samples;
           
           // Move outside terrain if stuck:
              while(_samples &gt; 0 &amp;&amp; (vehicle_collision_check(COL_RIGHT, MASK_MID, x, y, angle, -1) == true))
              {
                    x -= dcos(angle);
                    y += dsin(angle);                  
              }
              while(_samples &lt; 0 &amp;&amp; (vehicle_collision_check(COL_LEFT, MASK_MID, x, y, angle, -1) == true))
              {
                    x += dcos(angle);                   
                    y -= dsin(angle);
              } 
        
           // Object handling:
                         
           // Handling:
              vehicle_handle_layers();
                    
           // Terrain/Slope movement:                         
              if(ground)
              {
                 while(vehicle_collision_check(COL_MAIN, x, y, -1, -1, -1))
                 {
                       x -= dsin(angle);
                       y -= dcos(angle);
                 }
                 if(vehicle_collision_check(COL_SLOPE, MASK_MID, x, y, angle, -1))
                 {
                    while (!vehicle_collision_check(COL_MAIN, x, y, -1, -1, -1))
                    {
                              x += dsin(angle);
                              y += dcos(angle); 
                    }
                 }
              
              // Get new angles:
                 if(y_allow)
                 {
                    if(vehicle_collision_check(COL_LEFT_EDGE, x, y, angle, -1, -1) &amp;&amp; vehicle_collision_check(COL_RIGHT_EDGE, x, y, angle, -1, -1))
                    {
                       angle = vehicle_calculate_angle(x, y, angle);
                    }
                 }
              }   
        
           // Object handling:

              
           // Abort.
              if(x_speed == 0)
              {
                 break;
              }                  
    }
    
 // Move vertically:
    if(y_allow)
    {
    
       // Limit vertical speeds:
          if(y_limit)
          {
             y_speed = clamp(y_speed, -y_speed_max, y_speed_max);
          }
          
       // Set steps/samples:
          if(!ground)
          {
                 var _ysteps, _ysamples;
                 _ysteps = 1;
                 if(x_sample &gt; 0)
                 {
                    _ysteps += floor(abs(y_speed)/y_sample);
                 }
                 
                 _ysamples = y_speed/_ysteps;
                 
                 repeat(_ysteps)
                 {                   
                        x += dsin(angle)*_ysamples;
                        y += dcos(angle)*_ysamples;
           
                        // Move outside terrain if stuck:
                           while(_ysamples &lt; 0 &amp;&amp; (vehicle_collision_check(COL_TOP, MASK_MID, x, y, 0, -1) == true))
                           {
                                 x += dsin(angle);                                 
                                 y += dcos(angle);
                           }
                           while(_ysamples &gt; 0 &amp;&amp; (vehicle_collision_check(COL_BOTTOM, MASK_MID, x, y, 0, -1) == true))
                           {
                                 x -= dsin(angle);                                
                                 y -= dcos(angle);
                           }  
              
                        // Handling:
                           vehicle_handle_layers();     
                                                                         
                        // Check for landing:
                           if(y_speed &gt;= 0 &amp;&amp; vehicle_collision_check(COL_BOTTOM, MASK_BIG, x, y, 0, -1))
                           {                           
                              // Set Calculate angles:
                                 if(vehicle_collision_check(COL_LEFT_EDGE, x, y, 0, -1, -1) &amp;&amp; vehicle_collision_check(COL_RIGHT_EDGE, x, y, 0, -1, -1))
                                 {
                                    vehicle_angle(vehicle_calculate_angle(x, y, angle));
                                 }else{
                                    vehicle_angle(0);
                                 }
                                 
                              // Check if landed on obstacles:
                                 if(vehicle_collision_check(COL_BOTTOM_OBJECT, MASK_MAIN, x, y, angle, par_obstacles))
                                 {
                                    vehicle_angle(0);
                                 }                  
                                 
                              // Change horizontal speed upon landing on flat terrain or slopes.          
                                 if(abs(x_speed) &lt;= abs(y_speed) &amp;&amp; angle_relative &gt;= 22.5 &amp;&amp; angle_relative &lt;= 337.5)
                                 {
                                    x_speed = -y_speed*sign(dsin(angle_relative));
                                    if(angle_relative &lt; 45 || angle_relative &gt; 315)
                                    { 
                                       x_speed *= 0.5; 
                                    }
                                 }
                                 
                              // Set ground flag.
                                 y_speed = 0;
                                 ground  = true;
                                 
                              // Return to normal state:
                                 if(state == STATE_HURT || state == STATE_JUMP)
                                 {
                                    state = STATE_DEFAULT;
                                 }
                                 
                              
                           }
                           
                        // Ceiling handling:
                           if((y_speed &lt; 0 &amp;&amp; vehicle_collision_check(COL_TOP, MASK_LARGE, x, y, 0, -1)) &amp;&amp; (!vehicle_collision_check(COL_TOP_OBJECT, MASK_LARGE, x, y, angle, par_obstacles)))
                           {
                              // Set angle:
                                 vehicle_angle(180);                                 
                              
                              // Check if it's possible to land on the ceiling.
                                 if(vehicle_collision_check(COL_LEFT_EDGE, x, y, angle, -1, -1) &amp;&amp; vehicle_collision_check(COL_RIGHT_EDGE, x, y, angle, -1, -1))
                                 {
                                    // Calculate angle:
                                       vehicle_angle(vehicle_calculate_angle(x, y, angle));
                                       
                                    // Check if the angle isn't flat:
                                       if(angle_relative &gt; 160 &amp;&amp; angle_relative &lt; 200)
                                       {
                                          vehicle_angle(0);
                                          y_speed = 0;
                                       }
                                       
                                    // If the angle isn't flat, set new movement values:
                                       x_speed -= dsin(angle)*y_speed;
                                       ground   = true;
                                 }
                                 else
                                 {
                                    // Set angle:
                                       vehicle_angle(0);
                                       y_speed = 0;
                                       if not(ground)
                                       {
                                          break;
                                       }
                                 }                               
                           }   
                           
                           // Do another wall Collision check to prevent any glitches:                         
                              while(vehicle_collision_check(COL_RIGHT, MASK_MID, x, y, angle, -1))
                              {
                                    x -= dcos(angle);
                                    y += dsin(angle);
                              }    
                              while(vehicle_collision_check(COL_LEFT, MASK_MID, x, y, angle, -1))
                              {
                                    x += dcos(angle);
                                    y -= dsin(angle);
                              }
                           
                           // Handling:

                              
                           // Abort:
                              if(y_speed == 0)
                              {
                                 break; 
                              }                                                                                                                                                                                  
                 } 
          }    
            
          // Fall off the ground if the edges aren't colliding         
             if(ground &amp;&amp; angle != 0){
                if(!vehicle_collision_check(COL_LEFT_EDGE, x, y, angle, -1, -1) || !vehicle_collision_check(COL_RIGHT_EDGE, x, y, angle, -1, -1)){
                   if(floor_mode == 1 || floor_mode == 3){           
                      y_speed       = -(dsin(angle_relative) * g_speed)                                
                      x_speed       =   dcos(angle_relative) * x_speed;
                      launch_lock   = 3;
                      ground        = false;              
                      shield_usable = false;               
                   }else{
                      ground  = false;
                      y_speed = -dsin(angle)*x_speed;
                      x_speed =  dcos(angle)*x_speed;                   
                   }
                }
             }                                                      
    }

 // Launch lock:
    if(launch_lock)
    {
       launch_lock -= 1;
       x_speed = 0;
    }if(launch_lock &lt; 0) { launch_lock = 0 }
 
 // Get ground speed:
    vehicle_gspeed();
 
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Horizontal movement.

 // Exit if not initialized or death.
    if(initialized = false || state = STATE_DEATH) exit;

 // Input alarm. Ignores left or right input if above zero.
    if(input_alarm)
    {
       input_alarm -= 1;
    }else{
       input_alarm     = 0;
       input_alarm_dir = 0;
    }
    
    if(input_alarm &amp;&amp; angle == 0)
    {
       input_alarm     = 0;
       input_alarm_dir = 0;
    }
    
 // Store Accel/Decel changes.
    if(ground)
    {
       x_temp_accel    = x_acceleration;
       x_temp_decel    = x_deceleration;
       x_temp_friction = x_temp_accel;
    }else{
       x_temp_accel    = x_acceleration * 2;
       x_temp_decel    = 0;
       x_temp_friction = 0;
    }
    
 // Exit if we're not allowing x movement:
    if(x_allow == false) exit;
    
 // Decelerate on slopes:
       if(state = STATE_ROLL &amp;&amp; ground)
       {
          // Rolling up a slope:
             if((angle_relative &lt; 180 &amp;&amp; x_speed &gt; 0) || (angle_relative &gt; 180 &amp;&amp; x_speed &lt; 0))
             {
                x_speed -= dsin(angle_relative)*roll_decel_up;
             }else{
                x_speed -= dsin(angle_relative)*roll_decel_down;
             }
       }else{
          // Decelerate normally:
             if(ground &amp;&amp; ((angle_relative &gt; 35 &amp;&amp; angle_relative &lt; 330) || round(x_speed) != 0 || input_alarm != 0))
             {
                x_speed -= dsin(angle_relative) * 0.125;
             }
       }
    
 // Continue if in one of the following states.
    if((state == STATE_DEFAULT || (state = STATE_JUMP &amp;&amp; !jump_lock)))
    {
       // Handle Accel/Decel:
          if((ground &amp;&amp; input_alarm == 0))
          {
             if(input_left == true)
             {
                if(x_speed &gt; 0)
                {
                   x_speed -= x_temp_decel;
                }else{
                   if(x_speed &gt; -x_speed_top)
                   {
                      x_speed -= x_temp_accel;
                   }
                }
             }else if(input_right == true)
             {
                if(x_speed &lt; 0)
                {
                   x_speed += x_temp_decel;
                }else{
                   if(x_speed &lt; x_speed_top)
                   {
                      x_speed += x_temp_accel;
                   }
                }                
             }else{
                x_speed -= min(abs(x_speed), x_temp_friction)*sign(x_speed);
             }
          }else{
             // Air Cap:
                if(y_speed &gt; 16)
                {
                   y_speed = 16;
                }
                
             // Air acceleration:
                if(input_right)
                {
                      x_speed += x_air_accel;
                }
                
                if(input_left)
                {
                      x_speed -= x_air_accel;
                }
          }
    }
   
 // Fall if there's not enough speed:
    if(angle_relative &gt; 45 &amp;&amp; angle_relative &lt; 315 &amp;&amp; ground == true &amp;&amp; abs(x_speed) &lt; 2.5 &amp;&amp; tunnel_lock = 0)
    {
       if(angle_relative &gt;= 90 &amp;&amp; angle_relative &lt;= 270)
       {
          y_speed = -dsin(angle_relative)*x_speed;
          x_speed =  dcos(angle_relative)*x_speed;
          ground  = false;
       }else{
          input_alarm = 40;
          if(input_alarm_dir == 0)
          {
             input_alarm_dir = animation_direction;
          }
       }
    }
     
 // Get new angle:
    if(ground &amp;&amp; vehicle_collision_check(COL_LEFT_EDGE, x, y, angle, -1, -1)
              &amp;&amp; vehicle_collision_check(COL_RIGHT_EDGE, x, y, angle, -1, -1))
    {
       vehicle_angle(vehicle_calculate_angle(x, y, angle));
    }else{
       vehicle_angle(0);
    }
   
 // Full stop when colliding with a wall.
    if((x_speed &gt; 0 &amp;&amp; vehicle_collision_check(COL_RIGHT, MASK_BIG, x, y, angle, -1)) || (x_speed &lt; 0 &amp;&amp; vehicle_collision_check(COL_LEFT, MASK_BIG, x, y, angle, -1))){
        x_speed = 0;
    }

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Vertical movement.

 // Exit if not initialized or death.
    if(initialized = false || state = STATE_DEATH) exit;
    
 // Exit if we're not allowing x movement:
    if(y_allow == false) exit;
            
 //  Return to a normal state:
     if(ground)
     {
        y_speed = 0;
        if(state = STATE_JUMP || state = STATE_HURT)
        {
           if(state = STATE_HURT)
           {
              x_speed = 0;
           }
           state = STATE_DEFAULT;
        }
        
        // Check if the player is really grounded:
           if(vehicle_collision_check(COL_BOTTOM, MASK_BIG, x, y, angle, -1) == false)
           {
              ground = false;
              vehicle_angle(0);
           }
     }
     
 // Otherwise, add gravity:
    if(!ground)
    {
           // Gravity:           
                 y_speed += y_acceleration;
              
           // Check if we landed:
              if(y_speed &gt;= 0 &amp;&amp; vehicle_collision_check(COL_BOTTOM, MASK_BIG, x, y, angle, -1) == true)
              {
                 // We grounded:
                    ground = true;
                    aud_play_simple(snd_car_land);
                    
                 // Return to normal state:
                    if(state = STATE_JUMP || state = STATE_HURT)
                    {
                       if(state = STATE_HURT)
                       {
                          x_speed = 0;
                       }
                       state = STATE_DEFAULT;
                    }
              }
              
           // Check if we're in the air but collide with a ceiling.
              if(y_speed &lt; 0 &amp;&amp; vehicle_collision_check(COL_TOP, MASK_BIG, x, y, angle, -1) == true)
              {
                 y_speed = 0;
                 if(state = STATE_DEFAULT &amp;&amp; x_speed == 0 &amp;&amp; y_speed == 0)
                 { 
                    state = STATE_ROLL;
                 }
              }
    }
     
 // Reset horizontal speed after getting hurt.
    if(y_speed &gt;= 0 &amp;&amp; vehicle_collision_check(COL_BOTTOM, MASK_MAIN, x, y, angle, -1) == true)
    {
       if(state == STATE_HURT)
       {
          x_speed = 0;
          state   = STATE_DEFAULT;
       }
    }

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Air drag and floor mode.

 // Exit if not initialized or death.
    if(initialized = false || state = STATE_DEATH) exit;
    
 // Air Drag:
    if(ground == false &amp;&amp; state != STATE_HURT)
    {
       if(y_speed &lt; 0 &amp;&amp; y_speed &gt;= -4)
       {
          x_speed -= ((x_speed / 0.125) / 256);
       }
    }
    
 // Return the floor mode:
    floor_mode = round(angle/90) mod 4;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="par_hurt">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if !instance_exists(obj_death_handler)
{
    with obj_player
    {
        state = STATE_DEATH;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="par_enemy">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>with other
{
    scr_display_hp(x,y,"enemy","-" + string(enemy_max_hp) + "/" + string(enemy_max_hp))             
    enemy_hp        = 0;
    event_user(11);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_block_switch">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>with other
{
    event_user(0);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_player_killer">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if !instance_exists(obj_death_handler)
{
    with obj_player
    {
        state = STATE_DEATH;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_pellet">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>with other
{
    if follow = true
    {
    event_user(0);
    instance_destroy();
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_collectable">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>with other
{
    event_user(0);
    instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_sprite_ext(sprite_index, floor(animation_frame), floor(x), floor(y), 1, 1, animation_angle, c_white, 1);    

    // Draw Names
    if global.online_enabled
    {
        if global.show_names
        {
            draw_name(x,y,string(gms_self_name()),gms_self_admin_rights())
        }
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
